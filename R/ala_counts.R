#' Counts for ALA records
#'
#' Takes filters in the same format as `ala_occurrences`, with an
#' additional break down by `group_by`
#'
#' @param taxa string: single species ID or vector of species ids. Use
#' `ala_taxa()` to lookup species id.
#' @param filters data.frame: generated by `select_filters()`
#' @param locations string: WKT generated by `select_locations()`
#' @param group_by field to count by
#' @param limit numeric: maximum number of categories to return. 20 by default.
#' If limit is NULL, all results are returned. For some categories this will
#' take a while. 
#' @param caching logical: should the results be cached/use cache? Only used if
#' `group_by` is supplied.
#' @return either single integer of total counts, or a dataframe of counts by
#' `group_by` field, if specified.
#' @examples
#' # Count of records in the ALA
#' ala_counts()
#' # Counts by state and territory
#' ala_counts(group_by = "state")
#' @export ala_counts

ala_counts <- function(taxa, filters, locations, group_by,
                       limit = 20, caching = FALSE) {
  query <- list()
  page_size <- 100

  if (!missing(taxa)) {
    # should species id be validated?
    if (inherits(taxa, "data.frame") &&
        "taxon_concept_id" %in% colnames(taxa)) {
      taxa <- taxa$taxon_concept_id
    }
    assert_that(is.character(taxa))
    taxa_query <- build_taxa_query(taxa)
  } else {
    taxa_query <- NULL
  }

  # validate filters
  if (!missing(filters)) {
    assert_that(is.data.frame(filters))
    filter_query <- build_filter_query(filters)
  } else {
    filter_query <- NULL
  }

  query$fq <- c(taxa_query, filter_query)

  if (!missing(locations)) {
    # convert area to wkt if not already
    area_query <- locations
    query$wkt <- area_query
  } else {
    area_query <- NULL
  }

  if (check_for_caching(taxa_query, filter_query, area_query)) {
    query <- cached_query(taxa_query, filter_query, area_query)
  }

  if (missing(group_by)) {
    return(record_count(query))
  }

  # check facet is valid
  validate_facet(group_by)
  group_by <- dwc_to_ala(group_by)
  query$facets <- group_by
  
  url <- getOption("koala_server_config")$base_url_biocache
  path <- "ws/occurrence/facets"
  cache_file <- cache_filename(args = c(url, path, unlist(query), limit,
                                        group_by),
                               ext = ".csv")
  if (caching && file.exists(cache_file)) {
    return(read.csv(cache_file))
  }
  
  total_cats <- total_categories(url, path, query)
  if (total_cats == 0) {
    counts <- data.frame(
      name = as.character(),
      count = as.numeric()
    )
    return(counts)
  } 
  
  if (total_cats > limit && total_cats > page_size) { 
    resp <- ala_GET(url, path, params = query, paginate = TRUE, limit = limit,
                    page_size = page_size)
    counts <- data.table::rbindlist(
      lapply(resp, function(x) {
        fromJSON(x)$fieldResult[[1]]
        }
        )
      )
    } else {
      query$flimit <- limit
      resp <- ala_GET(url, path, params = query)
      counts <- resp$fieldResult[[1]]
  }

  if (total_cats > limit) {
    warning("This field has ", total_cats, " values. ", limit,
            " will be returned. Change `limit` to return more values.")
  }
  # parse out field value
  value <- parse_fq(counts$fq)
  counts <- data.frame(
    name = value,
    count = counts$count
  )
  if (caching) {
    write.csv(counts, cache_file)
  }
  return(counts)
}

# get just the record count for a query
# handle too long queries in here?
record_count <- function(query) {
  query$pageSize <- 0
  url <- getOption("koala_server_config")$base_url_biocache
  resp <- ala_GET(url, "ws/occurrences/search", query)
  resp$totalRecords
}

validate_facet <- function(facet) {
  if (!facet %in% c(find_fields()$name, all_fields()$name)) {
    stop("\"", facet, "\" is not a valid group_by field. ",
         "Use `find_fields()` to get a list of valid options")
  }
}

total_categories <- function(url, path, query) {
  query$flimit <- 1
  resp <- ala_GET(url, path, params = query)
  if (is.null(resp$count)) {
    return(0)
  }
  resp$count
}

parse_fq <- function(fq) {
  vapply(fq, function(z) {
    sub('.*?"([^"]+)"', "\\1", z)
  }, USE.NAMES = FALSE, FUN.VALUE = character(1))
}
